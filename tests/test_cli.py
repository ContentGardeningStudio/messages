"""messages.cli tests."""

import builtins
import sys

import pytest
import conftest

import click
from click import Context
from click.testing import CliRunner

from messages import MESSAGES

import messages.cli
from messages.cli import get_body_from_file
from messages.cli import trim_args
from messages.cli import create_config_entry
from messages.cli import send_message
from messages.cli import main
from messages.email_ import Email
from messages._exceptions import UnsupportedMessageTypeError


##############################################################################
# FIXTURES
##############################################################################

class ClickConfig(Context):
    """Used to pass ctx for click applications."""
    def __init__(self): pass
    def get_usage(self): pass


@pytest.fixture()
def get_ctx():
    """Returns a mocked click.Context() object."""
    return ClickConfig()


@pytest.fixture()
def main_mocks(mocker):
    """Returns mocks for all funcs inside main()."""
    body_mk = mocker.patch.object(messages.cli, 'get_body_from_file')
    config_mk = mocker.patch.object(messages.cli, 'create_config_entry')
    send_mk = mocker.patch.object(messages.cli, 'send')
    return (body_mk, config_mk, send_mk)


##############################################################################
# TESTS: cli.get_body_from_file
##############################################################################

@conftest.travis
def test_get_body_from_file(tmpdir):
    """
    GIVEN a call to messages via the CLI
    WHEN a message is specified by filename
    THEN assert the file contents are read and set into the message body
        * this uses the tmpdir pytest built-in fixture to create temporary
          directory and file for the test
    """
    msg_file = tmpdir.join('msg.txt')
    msg_file.write('This is the message to send!')
    kwds = {'body': None, 'file': msg_file}
    body = get_body_from_file(kwds)
    assert kwds == {'body': 'This is the message to send!', 'file': None}


##############################################################################
# TESTS: cli.trim_args
##############################################################################

def test_trim_args_rejectedKV():
    """
    GIVEN a call to messages via the CLI
    WHEN trim_args is called on the CLI args
    THEN assert the correct args are removed
    """
    kwds = {'type': 'email', 'arg1': None, 'arg2': (), 'arg3': 'valid'}
    kwargs = trim_args(kwds)
    assert kwargs == {'arg3': 'valid'}


def test_trim_args_ListItems():
    """
    GIVEN a call to messages via the CLI
    WHEN trim_args is called on the CLI args
    THEN assert values with keys to/cc/bcc/attach are returned as a list
        instead of the tuple generated by the click package
    """
    kwds = {'to': ('me@here.com',), 'cc': ('her@there.com',),
            'bcc': ('him@there.com', 'her@there.com'), 'attachments': ('file1',)}
    kwargs = trim_args(kwds)
    assert kwargs == {'to': ['me@here.com'], 'cc': ['her@there.com'],
            'bcc': ['him@there.com', 'her@there.com'], 'attachments': ['file1']}


##############################################################################
# TESTS: cli.create_config_entry
##############################################################################

def test_create_config_entry_yes_email(capsys, mocker):
    """
    GIVEN a call to messages via the CLI
    WHEN create_config_entry is called with a valid message type with user
        input=yes
    THEN assert correct output is printed and create_config is called
    """
    input_mk = mocker.patch.object(builtins, 'input', return_value='y')
    create_cfg_mk = mocker.patch.object(messages.cli, 'create_config')
    create_config_entry('email')
    out, err = capsys.readouterr()
    assert 'You will need the following information to configure: email' in out
    assert 'from_' in out
    assert 'server' in out
    assert 'port' in out
    assert 'password' in out
    assert input_mk.call_count == 2
    assert create_cfg_mk.call_count == 1


def test_create_config_entry_yes_twilio(capsys, mocker):
    """
    GIVEN a call to messages via the CLI
    WHEN create_config_entry is called with a valid message type with user
        input=yes
    THEN assert correct output is printed and create_config is called
    """
    input_mk = mocker.patch.object(builtins, 'input', return_value='y')
    create_cfg_mk = mocker.patch.object(messages.cli, 'create_config')
    create_config_entry('twilio')
    out, err = capsys.readouterr()
    assert 'You will need the following information to configure: twilio' in out
    assert 'from_' in out
    assert 'acct_sid' in out
    assert 'auth_token' in out
    assert input_mk.call_count == 2
    assert create_cfg_mk.call_count == 1


def test_create_config_entry_yes_slackwebhook(capsys, mocker):
    """
    GIVEN a call to messages via the CLI
    WHEN create_config_entry is called with a valid message type with user
        input=yes
    THEN assert correct output is printed and create_config is called
    """
    input_mk = mocker.patch.object(builtins, 'input', return_value='y')
    create_cfg_mk = mocker.patch.object(messages.cli, 'create_config')
    create_config_entry('slackwebhook')
    out, err = capsys.readouterr()
    assert 'You will need the following information to configure: slackwebhook' in out
    assert 'from_' in out
    assert 'credentials' in out
    assert input_mk.call_count == 2
    assert create_cfg_mk.call_count == 1


def test_create_config_entry_yes_tgram(capsys, mocker):
    """
    GIVEN a call to messages via the CLI
    WHEN create_config_entry is called with a valid message type with user
        input=yes
    THEN assert correct output is printed and create_config is called
    """
    input_mk = mocker.patch.object(builtins, 'input', return_value='y')
    create_cfg_mk = mocker.patch.object(messages.cli, 'create_config')
    create_config_entry('telegrambot')
    out, err = capsys.readouterr()
    assert 'You will need the following information to configure: telegrambot' in out
    assert 'chat_id' in out
    assert 'credentials' in out
    assert input_mk.call_count == 2
    assert create_cfg_mk.call_count == 1


def test_create_config_entry_no(capsys, mocker):
    """
    GIVEN a call to messages via the CLI
    WHEN create_config_entry is called with a valid message type with user
        input=no
    THEN assert create_config is not called
    """
    input_mk = mocker.patch.object(builtins, 'input', return_value='n')
    create_cfg_mk = mocker.patch.object(messages.cli, 'create_config')
    create_config_entry('email')
    out, err = capsys.readouterr()
    assert input_mk.call_count == 1
    assert create_cfg_mk.call_count == 0


##############################################################################
# TESTS: cli.send_message
##############################################################################

def test_send_message(mocker):
    """
    GIVEN a call to messages via the CLI
    WHEN send_message is called with a valid message type with
        kwds['file'] = None
    THEN assert the correct sequence is called
    """
    send_mock = mocker.patch.object(messages.cli, 'send')
    trim_mock = mocker.patch.object(messages.cli, 'trim_args')
    file_mock = mocker.patch.object(messages.cli, 'get_body_from_file')
    send_message('email', kwds={'file': None})
    assert trim_mock.call_count == 1
    assert send_mock.call_count == 1
    assert file_mock.call_count == 0


def test_send_message_withFile(mocker):
    """
    GIVEN a call to messages via the CLI
    WHEN send_message is called with a valid message type with
        kwds['file'] != None
    THEN assert the correct sequence is called
    """
    send_mock = mocker.patch.object(messages.cli, 'send')
    trim_mock = mocker.patch.object(messages.cli, 'trim_args')
    file_mock = mocker.patch.object(messages.cli, 'get_body_from_file')
    send_message('email', kwds={'file': 'Some File'})
    assert trim_mock.call_count == 1
    assert send_mock.call_count == 1
    assert file_mock.call_count == 1


##############################################################################
# TESTS: cli.main
##############################################################################

def test_main_configure(mocker):
    """
    GIVEN a call to messages via the CLI
    WHEN subcommand = configure
    THEN assert the correct sequence is called
    """
    config_mock = mocker.patch.object(messages.cli, 'create_config_entry')
    runner = CliRunner()
    runner.invoke(main, ['configure', 'email'], catch_exceptions=False)
    assert config_mock.call_count == 1


@pytest.mark.parametrize('subcommand',
                         ['email',
                          'twilio',
                          'slackwebhook',
                          'slackpost',
                          'telegram',
                         ])
def test_main_message(subcommand, mocker):
    """
    GIVEN a call to a messages via the CLI
    WHEN subcommand = one of the message types
    THEN assert the correct sequence is called
    """
    send_mock = mocker.patch.object(messages.cli, 'send_message')
    runner = CliRunner()
    runner.invoke(main, [subcommand, '--verbose'], catch_exceptions=False)
    assert send_mock.call_count == 1
